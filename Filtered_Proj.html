<!DOCTYPE html>
<meta charset="utf-8" />
<html>

<head>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="_.js"></script>
    <H1>"Citi-Bike"</H1>
</head>

<body>

    <div class="control-group">
        <button onclick="visualize(subSet, saturday)">
            Saturday
        </button>
        <button onclick="visualize(subSet, sunday)">
            Sunday
        </button>
        <button onclick="visualize(subSet, monday)">
            Monday
        </button>
        <button onclick="visualize(subSet, tuesday)">
            Tuesday
        </button>
        <button onclick="visualize(subSet, wednesday)">
            Wednesday
        </button>
        <button onclick="visualize(subSet, thursday)">
            Thursday
        </button>
        <button onclick="visualize(subSet, friday)">
            Friday
        </button>
        <button onclick="visualize(subSet, xmas)">
            Christmas Day
        </button>
        <button onclick="visualize(subSet, newyears)">
            New Years Eve
        </button>
        <button onclick="visualize(subSet, subSet)">
            Full Week
        </button>
    </div>

    <script type="text/javascript">
        var margin = { top: 20, right: 20, bottom: 50, left: 75 };
        var width = 850 - margin.left - margin.right;
        var height = 1000 - margin.top - margin.bottom;
        var svgMap = d3.select('body').append('svg')
            .attr('width', width)
            .attr('height', height);
        var minDate;
        var tooltip = d3.select('body')
            .append('div')
            .style('position', 'absolute')
            .style('z-index', '10')
            .style('visibility', 'hidden')
            .style('font-family', 'Tahoma')
            .style('text-shadow', '0px 0px 1.5px lightblue')
            .style('background-color', '#FFFFFFB3');
        var projection = d3.geoMercator()
            .translate([(width) / 2, (height) / 2])
            .scale(200000)
            .center([-73.99, 40.72]);

        var svgDelta = d3.select('body').append('svg')
            .attr('width', width)
            .attr('height', height);
        var selectedStations = [];


        function proj(long, lat) {
            return projection([parseFloat(long), parseFloat(lat)]);
        }
        function bikeId(bike) {
            return 'Bike-' + bike['Bike ID'] + bike['Start Time'].replace(':', '_').replace(':', '_').replace(' ', '');
        }
        function Station(id, long, lat, name) {
            this.id = id;
            this.geo = [parseFloat(long), parseFloat(lat)];
            this.name = name;
            this.bikesIn = [];
            this.bikesOut = [];
        }
        function plotStations(data) {
            latMean = 0;
            longMean = 0;
            for (station in stations) {
                latMean += stations[station].geo[1];
                longMean += stations[station].geo[0];
            }
            var path = d3.geoPath()
                .projection(projection);

            svgMap.append('g')
                .selectAll('circle')
                .data(stations)
                .enter()
                .append('circle')
                .attr('id', function (d) { return 'Station' })
                .attr('cx', function (d) { return projection(d.geo)[0]; })
                .attr('cy', function (d) { return projection(d.geo)[1]; })
                .attr('r', '3px')
                .attr('fill', 'white')
                .attr('stroke', 'black')
                .attr('stroke-width', 1)
                .attr('count', 15)
                .on('mouseover', function (d) {
                    d3.select(this).attr('r', 5.5).style('fill', 'red');
                    tooltip.style('visibility', 'visible').text(d.name);
                })
                .on('mousemove', function (d) {
                    tooltip.style('top', (d3.event.pageY - 10) + 'px').style('left', (d3.event.pageX + 15) + 'px');
                })
                .on('mouseout', function (d) {
                    tooltip.style('visibility', 'hidden');
                    if (selectedStations.includes(d)) {
                        d3.select(this).attr('r', 4.5).style('fill', 'lightblue');
                    } else {
                        d3.select(this).attr('r', 3).style('fill', 'white');
                    }
                })
                .on('click', function (d) {
                    if (selectedStations.includes(d)) {
                        selectedStations.splice(selectedStations.indexOf(d), 1);
                    } else {
                        selectedStations.push(d);
                        d3.select(this).attr('r', 4.5).style('fill', 'lightblue');
                    }
                    plotStationsDelta(selectedStations);
                })
                .each(function (d, i) {
                    station = d3.select(this)
                    for (startTime in d.bikesIn) {
                        d3.select(this)
                            .transition()
                            .attr('count', function (d) { return station.attr('count') + 1; })
                            .attr('r', function (d) { return station.attr('count') + 1; })
                            //                .attr('fill', function(d) { return d3.interpolateRgb('red', 'blue')(d3.select(this).attr('count'));})
                            .delay(function (d) { return (new Date(startTime) - minDate) / 75000; });
                    }
                });
        }
        stations = []
        function addStationStart(id, long, lat, name, startTime) {
            if (lat != null && long != null) {
                station = stations.find((s) => s.name == name);
                if (station == null) {
                    station = new Station(id, long, lat, name);
                    stations.push(station);
                }
                if (startTime != null) {
                    station.bikesOut.push(new Date(startTime));
                    station.bikesOut.sort(date_sort_asc);
                }
            }
        }
        //TODO make stations sorted on station name, or preprocess this data on python and read that in.  
        function addStationEnd(id, long, lat, name, endTime) {
            if (lat != null && long != null) {
                station = stations.find((s) => s.name == name);
                if (station == null) {
                    station = new Station(id, long, lat, name);
                    stations.push(station);
                }
                if (endTime != null) {
                    station.bikesIn.push(new Date(endTime));
                    station.bikesIn.sort(date_sort_asc);
                }
            }
        }
        function findStations(data) {
            for (idx in data) {
                row = data[idx]
                addStationStart(row['Start Station ID'], row['Start Station Longitude'], row['Start Station Latitude'], row['Start Station Name'], row['Start Time']);
                addStationEnd(row['End Station ID'], row['End Station Longitude'], row['End Station Latitude'], row['End Station Name'], row['Stop Time']);
            }
        }
        function plotTrips(data) {
            svgMap.append('g')
                .selectAll('circle')
                .data(data)
                .enter()
                .append('circle')
                .attr('r', '3px')
                .attr('fill', 'blue')
                .attr('id', 'bike')
                .attr('cx', function (d) { return proj(d['Start Station Longitude'], d['Start Station Latitude'])[0]; })
                .attr('cy', function (d) { return proj(d['Start Station Longitude'], d['Start Station Latitude'])[1]; })
                .transition()
                .attr('cx', function (d) { return proj(d['End Station Longitude'], d['End Station Latitude'])[0]; })
                .attr('cy', function (d) { return proj(d['End Station Longitude'], d['End Station Latitude'])[1]; })
                .duration(function (d) { return d['Trip Duration'] * 5; })
                .delay(function (d) { return (new Date(d['Start Time']) - minDate) / 75000; })
        }
        var date_sort_asc = function (date1, date2) {
            if (date1 > date2) return 1;
            if (date1 < date2) return -1;
            return 0;
        };
        function plotStationsDelta(selectedStations) {
            svgDelta.selectAll('path').remove();
            for (i = 0; i < selectedStations.length; i++) {
                plotStationDelta(selectedStations[i].bikesIn, selectedStations[i].bikesOut);
            }
        }
        function plotStationDelta(bikesIn, bikesOut) {
            idxIn = 0;
            idxOut = 0;
            currentDate = minDate;
            currentDelta = 0;
            deltas = []
            maxDelta = 0;
            minDelta = 0;
            //TODO precalc this?
            while (idxIn < bikesIn.length && idxOut < bikesOut.length) {
                if (bikesIn[idxIn] < bikesOut[idxOut]) {
                    currentDelta++;
                    deltas.push([bikesIn[idxIn], currentDelta]);
                    idxIn++;
                } else if (bikesIn[idxIn] > bikesOut[idxOut]) {
                    currentDelta--;
                    deltas.push([bikesOut[idxOut], currentDelta]);
                    idxOut++;
                } else {
                    idxIn++;
                    idxOut++;
                }
                if (currentDelta > maxDelta) {
                    maxDelta = currentDelta;
                }
                if (currentDelta < minDelta) {
                    minDelta = currentDelta;
                }
            }
            var x = d3.scaleTime()
                .domain([Math.min(d3.min(bikesIn), d3.min(bikesOut)), Math.max(d3.max(bikesIn), d3.max(bikesOut))])
                .range([0, width]);
            var y = d3.scaleLinear()
                .domain([minDelta, maxDelta])
                .range([height, 0]);

            bikesIn = _.zip(bikesIn, _.range(bikesIn.length));
            bikesOut = _.zip(bikesOut, _.range(bikesOut.length));
            line = d3.line()
                .x(function (d, i) { return x(d[0]); })
                .y(function (d) { return y(d[1]); });
            //TODO make line different colors for ++ and --, plot zero.  Lastly make it so the lines start and stop at the same points.
            svgDelta.append('path')
                .attr('class', 'line')
                .attr('d', line(deltas))
                .attr('stroke', 'blue')
                .attr('stroke-width', 2)
                .attr('fill', 'none');
        }
        var parser = d3.timeParse("%Y-%m-%d %H:%M:%S");
        var formatDay = d3.timeFormat("%d")

        function visualize(subset, data) {
            findStations(data); //TODO speed up?
            minDate = d3.min(data, function (d) { return new Date(d['Start Time']); });
            console.log(data)
            plotTrips(data);
            plotStations(subset);
        }



        d3.csv('Data/201612-citibike-tripdata.csv').then(function (data) {

            // cant use all the data ~800000 rows
            console.log('loaded');
            subSet = _.take(_.shuffle(data), 1000)
            subSet.forEach(function (d) {
                d['Start Time'] = new Date((d['Start Time']))
            })


            saturday = _.filter(subSet, function (d) { return formatDay(d['Start Time']) % 7 == 4 });
            sunday = _.filter(subSet, function (d) { return formatDay(d['Start Time']) % 7 == 5 });
            monday = _.filter(subSet, function (d) { return formatDay(d['Start Time']) % 7 == 6 });
            tuesday = _.filter(subSet, function (d) { return formatDay(d['Start Time']) % 7 == 0 });
            wednesday = _.filter(subSet, function (d) { return formatDay(d['Start Time']) % 7 == 1 });
            thursday = _.filter(subSet, function (d) { return formatDay(d['Start Time']) % 7 == 2 });
            friday = _.filter(subSet, function (d) { return formatDay(d['Start Time']) % 7 == 3 });
            xmas = _.filter(subSet, function (d) { return formatDay(d['Start Time']) % 31 == 25 });
            newyears = _.filter(subSet, function (d) { return formatDay(d['Start Time']) % 31 == 0 });

            console.log(subSet)
            console.log(saturday)
            console.log(sunday)
            console.log(monday)
            console.log(tuesday)
            console.log(wednesday)
            console.log(thursday)
            console.log(friday)

            findStations(subSet); //TODO speed up?
            minDate = d3.min(subSet, function (d) { return new Date(d['Start Time']); });
            console.log(minDate.get)
            plotTrips(subSet);
            plotStations(subSet); //TODO color plotted should rotate through a cmap, shift click should pause rotation.
        });

    </script>
</body>

</html>